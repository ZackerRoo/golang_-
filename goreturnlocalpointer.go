package main

/* func main() {
/*
	一般而言局部变量会在函数返回时候自动销毁了 因此被返回的引用就成为了 无所指的引用

	但是go 语言会对变量进行逃逸分析 如果发现局部变量作用域超出了函数的范围则不会将内存分配在栈上而是直接在分配在
	堆上 由于不在栈上即便释放了函数该局部变量内容不受影响

*/
//fmt.Println("add(1, 2) = ", add(1, 2)) // 3
//}

/* func add(a, b int) *int {
	res := 0
	res = a + b
	return &res
}
*/
