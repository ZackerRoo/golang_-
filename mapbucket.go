package main

/* func main() {
// bucket 在map中一个bucket 最多可以放8个key

// 这些key的hash值的高8位相同
// 也就是说，这些key会被放到同一个bucket中
// 这样就会形成一个链表
// 这个链表的长度超过8的时候，会转换成红黑树
// 这样就可以提高查询的效率
// 但是这样也会增加插入和删除的复杂度
// 所以在go1.12中，对map做了优化
// 也就是当bucket中的元素个数小于8的时候，会使用链表
// 当bucket中的元素个数大于8的时候，会使用红黑树
// 这样就可以提高查询的效率，也可以减少插入和删除的复杂度
// 这样就可以提高map的性能
// map的遍历操作是无序的
// 如果想要有序的遍历map，需要将key放到slice中，然后对slice进行排序
// 这样就可以实现有序的遍历map
// 无序的主要原因是由于每次map的遍历
// 都会从一个随机的序号的bucket再从其中的链表中随机遍历
// map也是一个线程不安全的数据结构
// 为了实现线程安全主要有以下几种办法
// 1. 使用sync.Map 其存储数据和读取数据就变成了 m.store.Load() 和 m.store.Store() 了
// 2. 使用读写锁sync.RWMutex来为读写操作加锁

/*
	map 遇见冲突时的处理方式
	1. 链地址法  当发生冲突时候 会在冲突地方加一个链表并且将元素插入到链表中
	2. 开放地址法
		1. 线性探测 当发生冲突时候，会往后找一个空的位置如果不为空会一直往后找
		2. 二次探测
		3. 再哈希法
		4. 伪随机探测
*/

/*
	map 也是使用链表来解决hash冲突的 在发生冲突的bucket 中创建一个溢出桶
	map 的填装因子是 6.5 也就是说当map中的元素个数大于6.5倍的bucket的时候，会重新分配内存
	负载因子= 元素个数 / bucket个数 负载因子大于6.5的时候会重新分配内存 不会等装满的时候
*/

/*
	map 扩容主要要满足两个条件
	1. map中的元素个数大于6.5倍的bucket的时候
	2. map中的溢出桶的个数大于等于bucket的个数的时候
		第二种情况是由于map里面bucket多但是元素少导致空间浪费 第二章情况出现的条件是不停的增加删除元素
	扩容的时候会重新分配内存，然后将原来的元素重新插入到新的bucket中
*/
//}
